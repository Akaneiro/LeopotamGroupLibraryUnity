//-------------------------------------------------------
// LeopotamGroupLibrary for unity3d
// Copyright (c) 2012-2016 Leopotam <leopotam@gmail.com>
//-------------------------------------------------------
// Autogenerated with Coco/R, dont change it manually.
//-------------------------------------------------------

using System.Collections;
using System.Collections.Generic;
using LeopotamGroup.Common;


using System;
namespace LeopotamGroup.Serialization.JsonInternal {


class Parser {
	public const int _EOF = 0;
	public const int _NUMBER = 1;
	public const int _STRING = 2;
	public const int maxT = 12;

	const bool _T = true;
	const bool _x = false;
	const int _minErrDist = 2;

	readonly Scanner _scanner;

	Token t;    // last recognized token
	Token la;   // lookahead token
	int errDist = _minErrDist;

Type _type;

public object Result;

readonly Stack<ArrayList> _arrayPool = new Stack<ArrayList>(16);

ArrayList GetArrayItem() {
	if (_arrayPool.Count > 0) {
		return _arrayPool.Pop();
	}
	return new ArrayList();
}

void RecycleArrayItem(ArrayList item) {
	if (item != null) {
		item.Clear();
		_arrayPool.Push(item);
	}
}

public void SetType(Type type) {
	_type = type;
}
//----------------------------------------------------------------------------------------------------------------------


	public Parser(Scanner scanner) {
		_scanner = scanner;
	}

	void SynErr (int n) {
		if (errDist >= _minErrDist) {
			Errors.SynErr(la.line, la.col, n);
		}
		errDist = 0;
	}

	public void SemErr (string msg) {
		if (errDist >= _minErrDist) {
			Errors.SemErr(t.line, t.col, msg);
		}
		errDist = 0;
	}
	
	void Get () {
		while (true) {
			t = la;
			la = _scanner.Scan();
			if (la.kind <= maxT) {
				errDist++;
				break;
			}

			la = t;
		}
	}
	
	void Expect (int n) {
		if (la.kind==n) {
			Get();
		} else {
			SynErr(n);
		}
	}
	
	bool StartOf (int s) {
		return set[s, la.kind];
	}
	
	void ExpectWeak (int n, int follow) {
		if (la.kind == n) {
			Get();
		}
		else {
			SynErr(n);
			while (!StartOf(follow)) {
				Get();
			}
		}
	}

	bool WeakSeparator(int n, int syFol, int repFol) {
		var kind = la.kind;
		if (kind == n) {
			Get();
			return true;
		} else if (StartOf(repFol)) {return false;}
		else {
			SynErr(n);
			while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind])) {
				Get();
				kind = la.kind;
			}
			return StartOf(syFol);
		}
	}
	
	void Json() {
		Result = null; 
		Value(ref Result);
	}

	void Value(ref object v) {
		
		switch (la.kind) {
		case 2: {
			Get();
			if (_type != null) { v = t.val.Substring(1, t.val.Length - 2); } 
			break;
		}
		case 1: {
			Get();
			if (_type != null) { var n = t.val.ToFloatUnchecked(); v = _type.IsEnum ? Enum.ToObject(_type , (int)n) : Convert.ChangeType(n, _type, Extensions.NumberFormatInfo); } 
			break;
		}
		case 6: {
			Object(ref v);
			break;
		}
		case 10: {
			Array(ref v);
			break;
		}
		case 3: {
			Get();
			if (_type != null) { v = true; } 
			break;
		}
		case 4: {
			Get();
			if (_type != null) { v = false; } 
			break;
		}
		case 5: {
			Get();
			if (_type != null) { v = null; } 
			break;
		}
		default: SynErr(13); break;
		}
	}

	void Object(ref object v) {
		object v1 = null; var objType = _type; string name = null; System.Collections.IDictionary dict = null; Type[] dictTypes = null;
		if (_type != null) {
		v = Activator.CreateInstance(objType);
		dict = v as System.Collections.IDictionary;
		if (dict != null) {
			dictTypes = objType.GetGenericArguments();
		}
		}
		
		Expect(6);
		if (la.kind == 2) {
			Get();
			if (objType != null) { name = t.val; _type = dict != null ? dictTypes[1] : TypesCache.Instance.GetWantedType(objType, name); } 
			Expect(7);
			Value(ref v1);
			if (objType != null) {
			if (v1 != null) {
				if (dict != null) {
					dict.Add(Convert.ChangeType(name.Substring(1, name.Length - 2), dictTypes[0], Extensions.NumberFormatInfo), v1);
				} else {
					TypesCache.Instance.SetValue(objType, name, v, v1);
				}
			}
			_type = objType;
			} 
			while (la.kind == 8) {
				Get();
				Expect(2);
				if (objType != null) { name = t.val; _type = TypesCache.Instance.GetWantedType(objType, name); } 
				Expect(7);
				Value(ref v1);
				if (objType != null) { if (v1 != null) { TypesCache.Instance.SetValue(objType, name, v, v1); } _type = objType; } 
			}
		}
		Expect(9);
	}

	void Array(ref object v) {
		bool isArray = false;
		Type arrType = _type;
		Type itemType = null;
		ArrayList list = null;
		if (_type != null) {
		if (_type.GetInterface ("IList") == null) {
			SemErr(string.Format("Type '{0}' not compatible with array data", _type.Name));
		}
		isArray = arrType.IsArray;
		itemType = isArray ? arrType.GetElementType() : arrType.GetProperty ("Item").PropertyType;
		_type = itemType;
		list = GetArrayItem();
		}
		object v1 = null;
		
		Expect(10);
		if (StartOf(1)) {
			Value(ref v1);
			if (arrType != null) { list.Add(Convert.ChangeType(v1, itemType, Extensions.NumberFormatInfo)); _type = itemType; } 
			while (la.kind == 8) {
				Get();
				Value(ref v1);
				if (arrType != null) { list.Add(Convert.ChangeType(v1, itemType, Extensions.NumberFormatInfo)); _type = itemType; } 
			}
		}
		Expect(11);
		if (arrType != null) {
		if (isArray) {
			v = list.ToArray(itemType);
		} else {
			v = Activator.CreateInstance(arrType);
			var vList = v as IList;
			foreach (var i in list) {
				vList.Add(i);
			}
		}
		}
		RecycleArrayItem(list);
		
	}


	public string Parse() {
		la = Scanner.EmptyToken;
		try {
			Get();
		Json();
		Expect(0);

		} catch (Exception ex) {
			return ex.Message;
		}
		return null;
	}
	
	static readonly bool[,] set = {
		{_T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x},
		{_x,_T,_T,_T, _T,_T,_T,_x, _x,_x,_T,_x, _x,_x}

	};
}

static class Errors {
	const string ErrFormat = "-- line {0} col {1}: {2}"; // 0=line, 1=column, 2=text

	public static void SynErr (int line, int col, int n) {
		string s;
		switch (n) {
			case 0: s = "EOF expected"; break;
			case 1: s = "NUMBER expected"; break;
			case 2: s = "STRING expected"; break;
			case 3: s = "\"true\" expected"; break;
			case 4: s = "\"false\" expected"; break;
			case 5: s = "\"null\" expected"; break;
			case 6: s = "\"{\" expected"; break;
			case 7: s = "\":\" expected"; break;
			case 8: s = "\",\" expected"; break;
			case 9: s = "\"}\" expected"; break;
			case 10: s = "\"[\" expected"; break;
			case 11: s = "\"]\" expected"; break;
			case 12: s = "??? expected"; break;
			case 13: s = "invalid Value"; break;

			default: s = "error " + n; break;
		}
		SemErr(line, col, s);
	}

	public static void SemErr (int line, int col, string msg) {
		throw new Exception (string.Format(ErrFormat, line, col, msg));
	}
}}